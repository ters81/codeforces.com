
# B. Четный массив
# https://codeforces.com/problemset/problem/1367/B

# Вам дан массив a[0…n−1] длины n, который состоит из неотрицательных целых чисел. Обратите внимание: массив нумеруется с нуля.
#
# Назовём массив хорошим, если четность каждой позиции совпадает с четностью элемента в ней. Более формально,
# массив является хорошим, если для всех i (0≤i≤n−1) выполнено равенство imod2=a[i]mod2, где xmod2 — остаток от деления x на 2.
#
# Например, массивы [0,5,2,1] и [0,17,0,3] — хорошие, а массив [2,4,6,7] — плохой, потому что для i=1 четность i и a[i] различна:
# imod2=1mod2=1, но a[i]mod2=4mod2=0.
#
# За один ход вы можете взять любые два элемента массива и поменять их местами (эти элементы не обязательно соседние).
#
# Найдите минимальное количество ходов, за которое можно сделать массив a хорошим, либо укажите, что это сделать невозможно.
#
# Входные данные
# В первой строке записано одно целое число t (1≤t≤1000) — количество наборов тестовых данных в тесте.
# Далее следуют t наборов тестовых данных.
#
# Каждый набор начинается со строки, в которой записано целое число n (1≤n≤40) — размер массива a.
#
# Далее следует строка, содержащая n целых чисел a0,a1,…,an−1 (0≤ai≤1000) — исходный массив.
#
# Выходные данные
# Для каждого набора тестовых данных выведите одно целое число — минимальное количество ходов, за которое можно сделать
# заданный массив a хорошим, или -1, если это сделать невозможно.
#
# Пример
# входные данные
# 4
# 4
# 3 2 7 6
# 3
# 3 2 6
# 1
# 7
# 7
# 4 9 2 1 18 3 0
# выходные данные
# 2
# 1
# -1
# 0
# Примечание
# В первом наборе тестовых данных в первый ход можно поменять местами элементы на позициях 0 и 1,
# а во второй ход поменять местами элементы на позициях 2 и 3.
#
# Во втором наборе тестовых данных в первый ход надо поменять местами элементы на позициях 0 и 1.
#
# В третьем наборе тестовых данных нельзя сделать массив хорошим.



t = int(input())

for _ in range(t):
    n = int(input())
    a = list(map(int, input().split()))
    count1 = 0
    count2 = 0
    for i in range(len(a)):
        if i % 2 != a[i] % 2 and a[i] % 2 == 1:
            count1 += 1
        elif i % 2 != a[i] % 2 and a[i] % 2 == 0:
            count2 += 1
    print(count1 if count1 == count2 else -1)









